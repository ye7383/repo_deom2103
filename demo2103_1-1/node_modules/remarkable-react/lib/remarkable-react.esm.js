import React from 'react';

var assign = Object.assign || function (target) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  for (var i = 1; i < args.length; i++) {
    var source = args[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var defaultChildren = {
  footnote_anchor: function footnote_anchor() {
    return 'â†©';
  },
  footnote_ref: function footnote_ref(_ref) {
    var id = _ref.id;
    return '[' + (id + 1) + ']';
  },
  htmlblock: function htmlblock(_ref2, _ref3) {
    var content = _ref2.content;
    var html = _ref3.html;
    return html ? null : content;
  }
};

var defaultComponents = {
  a: 'a',
  blockquote: 'blockquote',
  br: 'br',
  code: 'code',
  del: 'del',
  em: 'em',
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  hr: 'hr',
  html: 'div',
  img: 'img',
  ins: 'ins',
  li: 'li',
  mark: 'mark',
  ol: 'ol',
  p: 'p',
  pre: 'pre',
  section: 'section',
  strong: 'strong',
  sub: 'sub',
  sup: 'sup',
  table: 'table',
  tbody: 'tbody',
  td: 'td',
  th: 'th',
  thead: 'thead',
  tr: 'tr',
  ul: 'ul'
};

var defaultRemarkableProps = {
  align: function align(_align) {
    return _align ? {
      key: 'style',
      value: { textAlign: _align }
    } : false;
  },
  alt: true,
  block: false,
  content: function content(_content, type) {
    return type === 'html' && {
      key: 'dangerouslySetInnerHTML',
      value: { __html: _content }
    };
  },
  hLevel: false,
  href: true,
  id: function id(_id, type, token) {
    switch (token.type) {
      case 'footnote_anchor':
        return {
          key: 'href',
          value: 'fn' + _id + ':' + (token.subId || 0)
        };
      case 'footnote_open':
        return { value: '#fn' + _id };
      case 'footnote_ref':
        return type === 'a' ? {
          key: 'href',
          value: '#fn' + _id
        } : {
          value: 'fn' + _id + ':' + (token.subId || 0)
        };
    }
  },
  level: false,
  lines: false,
  linkTarget: function linkTarget(target, type) {
    return type === 'a' && {
      key: 'target'
    };
  },
  order: false,
  params: false,
  src: true,
  subId: false,
  tight: false,
  title: true,
  type: false
};

var defaultTokens = {
  blockquote_open: 'blockquote',
  bullet_list_open: 'ul',
  code: 'code',
  del_open: 'del',
  em_open: 'em',
  fence: ['pre', 'code'],
  footnote_anchor: 'a',
  footnote_block_open: ['section', 'ol'],
  footnote_open: 'li',
  footnote_ref: ['sup', 'a'],
  hardbreak: 'br',
  heading_open: function heading_open(_ref) {
    var hLevel = _ref.hLevel;
    return 'h' + hLevel;
  },
  hr: 'hr',
  htmlblock: function htmlblock(_, _ref2) {
    var html = _ref2.html;
    return html && 'html';
  },
  image: 'img',
  ins_open: 'ins',
  link_open: 'a',
  list_item_open: 'li',
  mark_open: 'mark',
  ordered_list_open: 'ol',
  paragraph_open: 'p',
  softbreak: function softbreak(_, _ref3) {
    var breaks = _ref3.breaks;
    return breaks ? 'br' : undefined;
  },
  strong_open: 'strong',
  sub: 'sub',
  sup: 'sup',
  table_open: 'table',
  tbody_open: 'tbody',
  td_open: 'td',
  th_open: 'th',
  thead_open: 'thead',
  tr_open: 'tr'
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var OPEN_IDENTIFIER = '_open';
var CLOSE_IDENTIFIER = '_close';
var INLINE_TYPE = 'inline';

var isOpenToken = function isOpenToken(_ref) {
  var type = _ref.type;
  return type.includes(OPEN_IDENTIFIER);
};
var isCloseToken = function isCloseToken(_ref2) {
  var type = _ref2.type;
  return type.includes(CLOSE_IDENTIFIER);
};
var isInlineToken = function isInlineToken(_ref3) {
  var type = _ref3.type;
  return type === INLINE_TYPE;
};

var TokenTree = function () {
  function TokenTree() {
    var tokens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var options = arguments[1];
    var rOptions = arguments[2];
    classCallCheck(this, TokenTree);

    this.i = -1;
    this.tokens = tokens;
    this.options = options;
    this.rOptions = rOptions;

    return this.buildTokenTree();
  }

  createClass(TokenTree, [{
    key: 'getType',
    value: function getType(token) {
      return typeof this.options.tokens[token.type] === 'function' ? this.options.tokens[token.type](token, this.rOptions) : this.options.tokens[token.type];
    }
  }, {
    key: 'buildToken',
    value: function buildToken(token) {
      var _this = this;

      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getType(token);
      var children = arguments[2];

      if (Array.isArray(type)) {
        return type.reduceRight(function (child, typee, index) {
          return _this.buildToken(token, typee, index < type.length - 1 ? [child] : children);
        }, null);
      }

      if (!type) {
        return token.content;
      }

      return {
        type: type,
        props: this.buildTokenProps(type, token),
        children: children || (this.options.children[token.type] ? this.options.children[token.type](token, this.rOptions) : token.content)
      };
    }
  }, {
    key: 'buildTokenTree',
    value: function buildTokenTree() {
      var ts = this.tokens;
      var collection = [];

      while (++this.i < ts.length) {
        if (isOpenToken(ts[this.i])) {
          collection.push(this.buildToken(ts[this.i], this.getType(ts[this.i]), this.buildTokenTree()));
        } else if (isCloseToken(ts[this.i])) {
          return collection;
        } else if (isInlineToken(ts[this.i])) {
          new this.constructor(ts[this.i].children, this.options, this.rOptions).forEach(function (token) {
            return collection.push(token);
          });
        } else {
          collection.push(this.buildToken(ts[this.i]));
        }
      }

      return collection;
    }
  }, {
    key: 'buildTokenProps',
    value: function buildTokenProps(type, token) {
      var _this2 = this;

      var props = typeof this.options.components[type] === 'function' ? _extends({}, token, { options: this.rOptions }) : {};

      [token, this.rOptions].forEach(function (prps) {
        Object.keys(prps).forEach(function (prop) {
          var propValue = _this2.resolveProp(token, type, prop, prps[prop]);
          if (propValue) props[propValue.key] = propValue.value;
        });
      });

      return props;
    }
  }, {
    key: 'resolveProp',
    value: function resolveProp(token, type, prop, propValue) {
      var component = this.options.components[type];
      var resolver = this.options.remarkableProps[prop];

      if (!resolver) return;

      if (typeof resolver === 'function') {
        return this.resolveFunctionProp(type, resolver(propValue, type, token), prop, propValue);
      }

      if (typeof resolver === 'string') {
        return this.resolveStringProp(resolver, propValue);
      }

      if (resolver === true || typeof component === 'function') {
        return this.resolveTrueProp(prop, propValue);
      }
    }
  }, {
    key: 'resolveFunctionProp',
    value: function resolveFunctionProp(type, keyValue, prop, propValue) {
      if (keyValue) {
        return {
          key: keyValue.key || prop,
          value: keyValue.hasOwnProperty('value') ? keyValue.value : propValue
        };
      }
    }
  }, {
    key: 'resolveStringProp',
    value: function resolveStringProp(resolver, propValue) {
      return {
        key: resolver,
        value: propValue
      };
    }
  }, {
    key: 'resolveTrueProp',
    value: function resolveTrueProp(prop, propValue) {
      return {
        key: prop,
        value: propValue
      };
    }
  }]);
  return TokenTree;
}();

var Renderer = function () {
  function Renderer() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Renderer);

    this.options = assign({
      keyGen: function keyGen(token, index) {
        return index;
      }
    }, options, {
      children: assign({}, defaultChildren, options.children),
      components: assign({}, defaultComponents, options.components),
      remarkableProps: assign({}, defaultRemarkableProps, options.remarkableProps),
      tokens: assign({}, defaultTokens, options.tokens)
    });
  }

  createClass(Renderer, [{
    key: 'render',
    value: function render() {
      var tokens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var remarkableOptions = arguments[1];

      return this.renderTokenTree(this.buildTokenTree(tokens, remarkableOptions));
    }
  }, {
    key: 'buildTokenTree',
    value: function buildTokenTree(tokens, remarkableOptions) {
      return new TokenTree(tokens, this.options, remarkableOptions);
    }
  }, {
    key: 'renderTokenTree',
    value: function renderTokenTree(token) {
      var _this = this;

      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (Array.isArray(token)) return token.map(function (token, indx) {
        return _this.renderTokenTree(token, indx);
      });
      if (!token || !token.type) return token;
      if (!this.options.components[token.type]) return null;

      return React.createElement(this.options.components[token.type], assign({}, token.props, {
        key: this.options.keyGen(token, index)
      }), this.renderTokenTree(token.children));
    }
  }]);
  return Renderer;
}();

export { TokenTree };
export default Renderer;
